<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marine Research Vessel CBF Navigation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #001f3f, #0074D9, #2E86AB, #A23B72);
            font-family: 'Georgia', serif;
            color: white;
            overflow-x: auto;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .title {
            text-align: center;
            font-size: 2.8em;
            margin-bottom: 20px;
            color: #87CEEB;
            text-shadow: 0 0 30px #4682B4;
            font-family: 'Times New Roman', serif;
            font-weight: bold;
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #F0F8FF;
            font-style: italic;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 420px;
            gap: 30px;
            margin-bottom: 30px;
        }

        .simulation-panel {
            background: rgba(0, 31, 63, 0.7);
            border: 3px solid #4682B4;
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 30px rgba(70, 130, 180, 0.3);
        }

        .math-panel {
            background: rgba(0, 31, 63, 0.9);
            border: 3px solid #DAA520;
            border-radius: 20px;
            padding: 25px;
            height: fit-content;
            box-shadow: 0 0 25px rgba(218, 165, 32, 0.2);
        }

        canvas {
            border: 2px solid #4682B4;
            border-radius: 15px;
            background: linear-gradient(45deg, #001122, #003366);
            display: block;
            margin: 0 auto;
            box-shadow: inset 0 0 50px rgba(70, 130, 180, 0.2);
        }

        .controls {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(70, 130, 180, 0.2);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            min-width: 140px;
            border: 1px solid #4682B4;
        }

        .control-group h5 {
            margin: 0 0 8px 0;
            color: #DAA520;
            font-size: 1em;
            font-weight: bold;
        }

        .slider {
            width: 100%;
            margin: 5px 0;
            accent-color: #4682B4;
        }

        .math-section {
            margin: 20px 0;
            padding: 18px;
            background: rgba(70, 130, 180, 0.1);
            border-radius: 15px;
            border-left: 5px solid #87CEEB;
        }

        .math-title {
            color: #DAA520;
            font-size: 1.2em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
        }

        .formula {
            background: #001f3f;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            color: #87CEEB;
            font-size: 0.95em;
            overflow-x: auto;
            border: 1px solid #4682B4;
        }

        .vector-display {
            background: rgba(0, 31, 63, 0.8);
            padding: 12px;
            border-radius: 10px;
            margin: 12px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            border: 1px solid #4682B4;
        }

        .vector-item {
            margin: 6px 0;
            padding: 4px;
            border-radius: 4px;
        }

        .desired { background: rgba(218, 165, 32, 0.2); color: #DAA520; }
        .repulsion { background: rgba(220, 20, 60, 0.2); color: #DC143C; }
        .tangent { background: rgba(138, 43, 226, 0.2); color: #8A2BE2; }
        .final { background: rgba(34, 139, 34, 0.2); color: #228B22; }

        .obstacle-info {
            background: rgba(70, 130, 180, 0.1);
            padding: 12px;
            border-radius: 10px;
            margin: 10px 0;
            font-size: 0.9em;
            border: 1px solid #4682B4;
        }

        .legend {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 18px;
            margin: 25px 0;
        }

        .legend-item {
            background: rgba(0, 31, 63, 0.8);
            padding: 15px;
            border-radius: 12px;
            border-left: 5px solid;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.95em;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .legend-item.hazard { border-color: #DC143C; }
        .legend-item.detected { border-color: #FF4500; }
        .legend-item.vessel-track { border-color: #4682B4; }
        .legend-item.course-vec { border-color: #DAA520; }
        .legend-item.avoid-vec { border-color: #DC143C; }
        .legend-item.drift-vec { border-color: #8A2BE2; }
        .legend-item.nav-vec { border-color: #228B22; }

        .legend-symbol {
            width: 18px;
            height: 18px;
            border-radius: 4px;
        }

        .status-panel {
            background: rgba(70, 130, 180, 0.2);
            padding: 18px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
            border: 2px solid #4682B4;
        }

        .highlight {
            background: rgba(218, 165, 32, 0.3);
            padding: 3px 6px;
            border-radius: 4px;
        }

        button {
            padding: 8px 16px;
            border: 2px solid #4682B4;
            border-radius: 8px;
            background: #228B22;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        button:hover {
            background: #32CD32;
            box-shadow: 0 0 15px rgba(50, 205, 50, 0.5);
            transform: translateY(-2px);
        }
        
        #replayBtn {
            background: #4169E1;
        }
        
        #replayBtn:hover {
            background: #6495ED;
            box-shadow: 0 0 15px rgba(100, 149, 237, 0.5);
        }

        .greek-pattern {
            border-top: 3px solid #DAA520;
            border-image: repeating-linear-gradient(
                90deg,
                #DAA520 0px,
                #DAA520 10px,
                transparent 10px,
                transparent 20px
            ) 1;
            margin: 20px 0;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2.2em;
            }
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="title">Ναυτική Έρευνα - CBF Navigation System</h1>
        <div class="subtitle">Autonomous Marine Research Vessel Navigation in the Aegean Sea</div>
        <div class="greek-pattern"></div>
        
        <div class="main-content">
            <div class="simulation-panel">
                <canvas id="marineCanvas" width="700" height="700"></canvas>
                
                <div class="controls">
                    <div class="control-group">
                        <h5>Research Station Distance</h5>
                        <input type="range" class="slider" id="stationDistance" min="8" max="15" step="0.5" value="12">
                        <div id="stationValue">12</div>
                    </div>
                    <div class="control-group">
                        <h5>Vessel Speed</h5>
                        <input type="range" class="slider" id="vesselSpeed" min="0.3" max="2" step="0.1" value="1">
                        <div id="speedValue">1.0 kts</div>
                    </div>
                    <div class="control-group">
                        <h5>Sonar Noise</h5>
                        <input type="range" class="slider" id="sonarNoise" min="0" max="0.5" step="0.05" value="0.15">
                        <div id="noiseValue">0.15</div>
                    </div>
                    <div class="control-group">
                        <h5>Safety Buffer</h5>
                        <input type="range" class="slider" id="safetyBuffer" min="0.5" max="2" step="0.1" value="1.2">
                        <div id="safetyValue">1.2</div>
                    </div>
                    <div class="control-group">
                        <h5>Navigation Control</h5>
                        <button id="pauseBtn">Pause</button>
                        <button id="replayBtn" style="margin-left: 10px;">Replay</button>
                    </div>
                </div>

                <div class="status-panel">
                    <div><strong>Distance to Research Station:</strong> <span id="currentStationDistance">0</span> nautical miles</div>
                    <div><strong>Closest Marine Hazard:</strong> <span id="closestHazard">0</span> meters</div>
                    <div><strong>Mission Time:</strong> <span id="missionTime">0</span> hours</div>
                </div>
            </div>

            <div class="math-panel">
                <h3 style="color: #DAA520; text-align: center; margin-top: 0;">Real-Time Navigation Analysis</h3>
                
                <div class="math-section">
                    <div class="math-title">Desired Course Vector</div>
                    <div class="formula">v_course = (station - vessel) / ||station - vessel||</div>
                    <div class="vector-display">
                        <div class="vector-item desired">v_course = <span id="courseVector">[0, 0]</span></div>
                        <div class="vector-item desired">bearing = <span id="courseBearing">0°</span></div>
                    </div>
                </div>

                <div class="math-section">
                    <div class="math-title">Per-Hazard Analysis</div>
                    <div id="hazardAnalysis">
                        <!-- Dynamically populated -->
                    </div>
                </div>

                <div class="math-section">
                    <div class="math-title">Vector Composition</div>
                    <div class="formula">u_nav = v_course + Σ(avoidance_i + drift_i)</div>
                    <div class="vector-display">
                        <div class="vector-item final">u_navigation = <span id="navVector">[0, 0]</span></div>
                        <div class="vector-item final">speed = <span id="navSpeed">0</span> knots</div>
                    </div>
                </div>

                <div class="math-section">
                    <div class="math-title">Maritime CBF Mathematics</div>
                    <div class="formula">h_i = ||vessel - hazard_i|| - (r_i + safety_buffer)</div>
                    <div class="formula">avoidance_i = α * (safety - dist) / safety * ∇h_i</div>
                    <div class="formula">drift_i = β * perpendicular(∇h_i)</div>
                    <div style="font-size: 0.9em; color: #B0C4DE; margin-top: 10px;">
                        Where ∇h_i points away from marine hazard i, and drift helps navigate around obstacles in current.
                    </div>
                </div>
            </div>
        </div>

        <div class="greek-pattern"></div>

        <div class="legend">
            <div class="legend-item hazard">
                <div class="legend-symbol" style="background: #DC143C;"></div>
                <div><strong>Marine Hazards:</strong> Rocks, reefs, other vessels</div>
            </div>
            <div class="legend-item detected">
                <div class="legend-symbol" style="background: #FF4500;"></div>
                <div><strong>Sonar Detection:</strong> Real-time hazard identification</div>
            </div>
            <div class="legend-item vessel-track">
                <div class="legend-symbol" style="background: #4682B4;"></div>
                <div><strong>Vessel Track:</strong> Navigation path history</div>
            </div>
            <div class="legend-item course-vec">
                <div class="legend-symbol" style="background: #DAA520;"></div>
                <div><strong>Course Vector:</strong> Direct path to research station</div>
            </div>
            <div class="legend-item avoid-vec">
                <div class="legend-symbol" style="background: #DC143C;"></div>
                <div><strong>Avoidance Vectors:</strong> Collision prevention forces</div>
            </div>
            <div class="legend-item drift-vec">
                <div class="legend-symbol" style="background: #8A2BE2;"></div>
                <div><strong>Current Drift:</strong> Navigation around hazards</div>
            </div>
            <div class="legend-item nav-vec">
                <div class="legend-symbol" style="background: #228B22;"></div>
                <div><strong>Final Navigation:</strong> Composite course vector</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('marineCanvas');
        const ctx = canvas.getContext('2d');
        
        // Navigation state
        let isPaused = false;
        let time = 0;
        let vesselPos = { x: 50, y: 650 };
        let stationPos = { x: 650, y: 50 };
        let track = [{ ...vesselPos }];
        let maxTrackLength = 300;
        
        // Marine hazards (moving obstacles representing other vessels, rocks, etc.)
        let hazards = [
            { pos: { x: 300, y: 400 }, vel: { x: -0.2, y: 0.15 }, radius: 35, type: 'vessel', id: 0 },
            { pos: { x: 500, y: 150 }, vel: { x: -0.15, y: 0.3 }, radius: 40, type: 'reef', id: 1 },
            { pos: { x: 150, y: 500 }, vel: { x: 0.2, y: -0.1 }, radius: 30, type: 'vessel', id: 2 },
        ];
        
        // Navigation parameters
        let vesselSpeed = 1.0;
        let sonarNoise = 0.15;
        let safetyBuffer = 1.2;
        
        // Vector analysis data
        let navAnalysis = {
            course: { x: 0, y: 0 },
            avoidance: [],
            drift: [],
            final: { x: 0, y: 0 }
        };
        
        // Controls
        const stationSlider = document.getElementById('stationDistance');
        const speedSlider = document.getElementById('vesselSpeed');
        const noiseSlider = document.getElementById('sonarNoise');
        const safetySlider = document.getElementById('safetyBuffer');
        const pauseBtn = document.getElementById('pauseBtn');
        const replayBtn = document.getElementById('replayBtn');
        
        // Store initial state for replay
        const initialState = {
            vesselPos: { x: 50, y: 650 },
            stationPos: { x: 650, y: 50 },
            obstacles: [
                { pos: { x: 300, y: 400 }, vel: { x: -0.2, y: 0.15 }, radius: 35, type: 'vessel', id: 0 },
                { pos: { x: 500, y: 150 }, vel: { x: -0.15, y: 0.3 }, radius: 40, type: 'reef', id: 1 },
                { pos: { x: 150, y: 500 }, vel: { x: 0.2, y: -0.1 }, radius: 30, type: 'vessel', id: 2 },
            ]
        };
        
        function resetSimulation() {
            // Reset vessel position
            vesselPos.x = initialState.vesselPos.x;
            vesselPos.y = initialState.vesselPos.y;
            
            // Reset station position
            stationPos.x = initialState.stationPos.x;
            stationPos.y = initialState.stationPos.y;
            
            // Reset hazards to initial positions and velocities
            hazards = initialState.obstacles.map(obs => ({
                pos: { x: obs.pos.x, y: obs.pos.y },
                vel: { x: obs.vel.x, y: obs.vel.y },
                radius: obs.radius,
                type: obs.type,
                id: obs.id
            }));
            
            // Clear trail
            trail = [{ ...vesselPos }];
            
            // Reset time
            time = 0;
            
            // Reset vector analysis
            navAnalysis = {
                course: { x: 0, y: 0 },
                avoidance: [],
                drift: [],
                final: { x: 0, y: 0 }
            };
            
            // Unpause if paused
            if (isPaused) {
                isPaused = false;
                pauseBtn.textContent = 'Pause';
            }
        }
        
        stationSlider.addEventListener('input', (e) => {
            const dist = parseFloat(e.target.value) * 45;
            stationPos.x = vesselPos.x + dist * 0.7;
            stationPos.y = vesselPos.y - dist * 0.7;
            stationPos.x = Math.max(50, Math.min(650, stationPos.x));
            stationPos.y = Math.max(50, Math.min(650, stationPos.y));
            document.getElementById('stationValue').textContent = e.target.value;
        });
        
        speedSlider.addEventListener('input', (e) => {
            vesselSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = e.target.value + ' kts';
        });
        
        noiseSlider.addEventListener('input', (e) => {
            sonarNoise = parseFloat(e.target.value);
            document.getElementById('noiseValue').textContent = e.target.value;
        });
        
        safetySlider.addEventListener('input', (e) => {
            safetyBuffer = parseFloat(e.target.value);
            document.getElementById('safetyValue').textContent = e.target.value;
        });
        
        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
        });
        
        replayBtn.addEventListener('click', () => {
            resetSimulation();
        });
        
        function addSonarNoise(value, noiseLevel) {
            return value + (Math.random() - 0.5) * 2 * noiseLevel * 25;
        }
        
        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }
        
        function normalize(vec) {
            const mag = Math.sqrt(vec.x * vec.x + vec.y * vec.y);
            return mag > 0 ? { x: vec.x / mag, y: vec.y / mag, magnitude: mag } : { x: 0, y: 0, magnitude: 0 };
        }
        
        function getBearing(from, to) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            angle = (90 - angle) % 360;
            if (angle < 0) angle += 360;
            return angle;
        }
        
        function sonarDetection(hazards) {
            return hazards.map(hazard => ({
                pos: {
                    x: addSonarNoise(hazard.pos.x, sonarNoise),
                    y: addSonarNoise(hazard.pos.y, sonarNoise)
                },
                radius: hazard.radius,
                type: hazard.type,
                id: hazard.id
            }));
        }
        
        function marineNavigationCBF(vessel, station, detectedHazards) {
            // Course vector toward research station
            const course = normalize({
                x: station.x - vessel.x,
                y: station.y - vessel.y
            });
            
            let totalAvoidance = { x: 0, y: 0 };
            let totalDrift = { x: 0, y: 0 };
            let avoidanceVectors = [];
            let driftVectors = [];
            
            // Process each detected hazard
            detectedHazards.forEach(hazard => {
                const diff = { x: vessel.x - hazard.pos.x, y: vessel.y - hazard.pos.y };
                const dist = Math.sqrt(diff.x * diff.x + diff.y * diff.y);
                const safetyRadius = hazard.radius + safetyBuffer * 25;
                
                if (dist < safetyRadius + 60) { // Detection/influence zone
                    const gradient = { x: diff.x / dist, y: diff.y / dist };
                    
                    if (dist < safetyRadius) {
                        // Avoidance force (repulsion)
                        const avoidanceStrength = (safetyRadius - dist) / safetyRadius;
                        const avoidance = {
                            x: gradient.x * avoidanceStrength * 0.9,
                            y: gradient.y * avoidanceStrength * 0.9
                        };
                        
                        // Drift force (tangent for smooth navigation)
                        const drift = {
                            x: -gradient.y * avoidanceStrength * 0.5,
                            y: gradient.x * avoidanceStrength * 0.5
                        };
                        
                        totalAvoidance.x += avoidance.x;
                        totalAvoidance.y += avoidance.y;
                        totalDrift.x += drift.x;
                        totalDrift.y += drift.y;
                        
                        avoidanceVectors.push({ ...avoidance, hazardId: hazard.id, strength: avoidanceStrength, type: hazard.type });
                        driftVectors.push({ ...drift, hazardId: hazard.id, strength: avoidanceStrength, type: hazard.type });
                    }
                }
            });
            
            // Combine navigation forces
            const final = {
                x: course.x * 0.6 + totalAvoidance.x + totalDrift.x,
                y: course.y * 0.6 + totalAvoidance.y + totalDrift.y
            };
            
            // Limit to maximum vessel speed
            const speed = Math.sqrt(final.x * final.x + final.y * final.y);
            const maxSpeed = vesselSpeed;
            if (speed > maxSpeed) {
                final.x = (final.x / speed) * maxSpeed;
                final.y = (final.y / speed) * maxSpeed;
            }
            
            // Store for visualization
            navAnalysis = {
                course: course,
                avoidance: avoidanceVectors,
                drift: driftVectors,
                final: final,
                totalAvoidance: totalAvoidance,
                totalDrift: totalDrift
            };
            
            return final;
        }
        
        function drawArrow(start, direction, length, color, width = 2) {
            if (Math.abs(direction.x) < 0.001 && Math.abs(direction.y) < 0.001) return;
            
            const end = {
                x: start.x + direction.x * length,
                y: start.y + direction.y * length
            };
            
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            
            // Arrow head
            const angle = Math.atan2(direction.y, direction.x);
            const headLen = 10;
            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(end.x - headLen * Math.cos(angle - Math.PI/6), 
                      end.y - headLen * Math.sin(angle - Math.PI/6));
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(end.x - headLen * Math.cos(angle + Math.PI/6), 
                      end.y - headLen * Math.sin(angle + Math.PI/6));
            ctx.stroke();
        }
        
        function drawVessel(pos) {
            const x = pos.x;
            const y = pos.y;
            
            // Hull gradient for depth
            const hullGradient = ctx.createLinearGradient(x - 20, y - 5, x + 20, y + 15);
            hullGradient.addColorStop(0, '#87CEEB');
            hullGradient.addColorStop(0.5, '#4682B4');
            hullGradient.addColorStop(1, '#2F4F4F');
            
            // Main hull with elegant curve
            ctx.fillStyle = hullGradient;
            ctx.beginPath();
            ctx.moveTo(x - 20, y + 5);
            ctx.quadraticCurveTo(x - 22, y - 2, x - 18, y - 5);
            ctx.lineTo(x + 18, y - 5);
            ctx.quadraticCurveTo(x + 22, y - 2, x + 20, y + 5);
            ctx.quadraticCurveTo(x + 18, y + 12, x + 15, y + 10);
            ctx.lineTo(x - 15, y + 10);
            ctx.quadraticCurveTo(x - 18, y + 12, x - 20, y + 5);
            ctx.fill();
            
            // Hull waterline
            ctx.strokeStyle = '#B0E0E6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 18, y + 8);
            ctx.lineTo(x + 18, y + 8);
            ctx.stroke();
            
            // Hull outline
            ctx.strokeStyle = '#1e3a8a';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x - 20, y + 5);
            ctx.quadraticCurveTo(x - 22, y - 2, x - 18, y - 5);
            ctx.lineTo(x + 18, y - 5);
            ctx.quadraticCurveTo(x + 22, y - 2, x + 20, y + 5);
            ctx.stroke();
            
            // Main superstructure with gradient
            const superGradient = ctx.createLinearGradient(x - 14, y - 12, x + 14, y + 4);
            superGradient.addColorStop(0, '#F8F8FF');
            superGradient.addColorStop(0.5, '#E6E6FA');
            superGradient.addColorStop(1, '#D3D3D3');
            
            ctx.fillStyle = superGradient;
            ctx.fillRect(x - 14, y - 12, 28, 16);
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 14, y - 12, 28, 16);
            
            // Bridge with windows
            const bridgeGradient = ctx.createLinearGradient(x - 10, y - 20, x + 10, y - 12);
            bridgeGradient.addColorStop(0, '#F0F8FF');
            bridgeGradient.addColorStop(1, '#B0C4DE');
            
            ctx.fillStyle = bridgeGradient;
            ctx.fillRect(x - 10, y - 20, 20, 8);
            ctx.strokeStyle = '#4169E1';
            ctx.strokeRect(x - 10, y - 20, 20, 8);
            
            // Bridge windows
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x - 8, y - 18, 3, 4);
            ctx.fillRect(x - 3, y - 18, 3, 4);
            ctx.fillRect(x + 2, y - 18, 3, 4);
            ctx.fillRect(x + 7, y - 18, 3, 4);
            
            // Research lab containers
            ctx.fillStyle = '#FFFAF0';
            ctx.strokeStyle = '#CD853F';
            ctx.lineWidth = 1;
            ctx.fillRect(x - 12, y - 8, 6, 10);
            ctx.strokeRect(x - 12, y - 8, 6, 10);
            ctx.fillRect(x + 6, y - 8, 6, 10);
            ctx.strokeRect(x + 6, y - 8, 6, 10);
            
            // Equipment details
            ctx.fillStyle = '#FF6347';
            ctx.fillRect(x - 10, y - 6, 2, 2);
            ctx.fillRect(x + 8, y - 6, 2, 2);
            
            // Main mast with details
            ctx.strokeStyle = '#708090';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x, y - 20);
            ctx.lineTo(x, y - 35);
            ctx.stroke();
            
            // Radar array (rotating)
            const radarAngle = (time * 0.05) % (2 * Math.PI);
            ctx.save();
            ctx.translate(x, y - 35);
            ctx.rotate(radarAngle);
            ctx.strokeStyle = '#FF4500';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-6, 0);
            ctx.lineTo(6, 0);
            ctx.moveTo(0, -6);
            ctx.lineTo(0, 6);
            ctx.stroke();
            ctx.restore();
            
            // Communication antenna
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 5, y - 20);
            ctx.lineTo(x - 5, y - 28);
            ctx.moveTo(x + 5, y - 20);
            ctx.lineTo(x + 5, y - 25);
            ctx.stroke();
            
            // Research crane with realistic structure
            ctx.strokeStyle = '#B8860B';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 10, y - 10);
            ctx.lineTo(x + 18, y - 25);
            ctx.lineTo(x + 25, y - 20);
            ctx.stroke();
            
            // Crane cable
            ctx.strokeStyle = '#2F4F4F';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 25, y - 20);
            ctx.lineTo(x + 25, y - 5);
            ctx.stroke();
            
            // Navigation lights (enhanced)
            ctx.shadowColor = '#FF0000';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(x - 18, y - 2, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.shadowColor = '#00FF00';
            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(x + 18, y - 2, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.shadowColor = '#FFFFFF';
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(x, y - 22, 2, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // Wake/water displacement
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x - 15, y + 12);
            ctx.quadraticCurveTo(x - 8, y + 18, x - 20, y + 25);
            ctx.moveTo(x + 15, y + 12);
            ctx.quadraticCurveTo(x + 8, y + 18, x + 20, y + 25);
            ctx.stroke();
        }
        
        function drawResearchStation(pos) {
            const x = pos.x;
            const y = pos.y;
            
            // Platform foundation (underwater structure)
            ctx.fillStyle = '#2F4F4F';
            ctx.fillRect(x - 20, y - 5, 40, 15);
            
            // Main platform deck
            ctx.fillStyle = '#228B22';
            ctx.fillRect(x - 18, y - 12, 36, 8);
            ctx.strokeStyle = '#006400';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - 18, y - 12, 36, 8);
            
            // Support pillars
            ctx.fillStyle = '#708090';
            ctx.fillRect(x - 15, y - 12, 4, 15);
            ctx.fillRect(x + 11, y - 12, 4, 15);
            
            // Control tower
            ctx.fillStyle = '#32CD32';
            ctx.fillRect(x - 10, y - 25, 20, 13);
            ctx.strokeStyle = '#228B22';
            ctx.lineWidth = 1;
            ctx.strokeRect(x - 10, y - 25, 20, 13);
            
            // Windows in control tower
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(x - 8, y - 22, 4, 3);
            ctx.fillRect(x - 2, y - 22, 4, 3);
            ctx.fillRect(x + 4, y - 22, 4, 3);
            
            // Communication antenna
            ctx.strokeStyle = '#FF6347';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x, y - 25);
            ctx.lineTo(x, y - 40);
            ctx.stroke();
            
            // Antenna dish
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y - 35, 6, 0, Math.PI, true);
            ctx.stroke();
            
            // Scientific equipment
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(x - 16, y - 10, 6, 6);
            ctx.fillRect(x + 10, y - 10, 6, 6);
            
            // Underwater sensors (cables)
            ctx.strokeStyle = '#000080';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(x - 13, y + 10);
            ctx.lineTo(x - 13, y + 25);
            ctx.moveTo(x + 13, y + 10);
            ctx.lineTo(x + 13, y + 25);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Navigation beacon (flashing light)
            ctx.fillStyle = time % 60 < 30 ? '#FFD700' : '#FFA500';
            ctx.beginPath();
            ctx.arc(x, y - 40, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            // Signal transmission waves
            if (time % 120 < 60) {
                ctx.strokeStyle = 'rgba(144, 238, 144, 0.6)';
                ctx.lineWidth = 1;
                for (let i = 1; i <= 4; i++) {
                    ctx.beginPath();
                    ctx.arc(x, y - 35, i * 12, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
        }
        
        function drawHazard(hazard) {
            if (hazard.type === 'vessel') {
                // Draw sophisticated vessel silhouette
                const x = hazard.pos.x;
                const y = hazard.pos.y;
                const scale = hazard.radius / 30;
                
                // Hull with gradient for depth
                const hullGradient = ctx.createLinearGradient(x - 25*scale, y, x + 25*scale, y + 10*scale);
                hullGradient.addColorStop(0, '#DC143C');
                hullGradient.addColorStop(0.5, '#B22222');
                hullGradient.addColorStop(1, '#8B0000');
                
                // Elegant hull shape
                ctx.fillStyle = hullGradient;
                ctx.beginPath();
                ctx.moveTo(x - 25*scale, y + 5*scale);
                ctx.quadraticCurveTo(x - 28*scale, y - 2*scale, x - 22*scale, y - 5*scale);
                ctx.lineTo(x + 22*scale, y - 5*scale);
                ctx.quadraticCurveTo(x + 28*scale, y - 2*scale, x + 25*scale, y + 5*scale);
                ctx.quadraticCurveTo(x + 20*scale, y + 12*scale, x + 15*scale, y + 10*scale);
                ctx.lineTo(x - 15*scale, y + 10*scale);
                ctx.quadraticCurveTo(x - 20*scale, y + 12*scale, x - 25*scale, y + 5*scale);
                ctx.fill();
                
                // Hull waterline
                ctx.strokeStyle = '#FFB6C1';
                ctx.lineWidth = 2*scale;
                ctx.beginPath();
                ctx.moveTo(x - 22*scale, y + 8*scale);
                ctx.lineTo(x + 22*scale, y + 8*scale);
                ctx.stroke();
                
                // Superstructure with gradient
                const superGradient = ctx.createLinearGradient(x - 15*scale, y - 15*scale, x + 15*scale, y + 5*scale);
                superGradient.addColorStop(0, '#FFE4E1');
                superGradient.addColorStop(0.5, '#FFC0CB');
                superGradient.addColorStop(1, '#FFB6C1');
                
                ctx.fillStyle = superGradient;
                ctx.fillRect(x - 15*scale, y - 15*scale, 30*scale, 18*scale);
                ctx.strokeStyle = '#CD5C5C';
                ctx.lineWidth = 1*scale;
                ctx.strokeRect(x - 15*scale, y - 15*scale, 30*scale, 18*scale);
                
                // Bridge with modern design
                const bridgeGradient = ctx.createLinearGradient(x - 8*scale, y - 25*scale, x + 8*scale, y - 15*scale);
                bridgeGradient.addColorStop(0, '#F0F0F0');
                bridgeGradient.addColorStop(1, '#D3D3D3');
                
                ctx.fillStyle = bridgeGradient;
                ctx.fillRect(x - 8*scale, y - 25*scale, 16*scale, 10*scale);
                ctx.strokeStyle = '#A9A9A9';
                ctx.strokeRect(x - 8*scale, y - 25*scale, 16*scale, 10*scale);
                
                // Bridge windows
                ctx.fillStyle = '#87CEEB';
                for (let i = 0; i < 4; i++) {
                    ctx.fillRect(x - 6*scale + i*3*scale, y - 22*scale, 2*scale, 3*scale);
                }
                
                // Smokestack with smoke effect
                ctx.fillStyle = '#696969';
                ctx.fillRect(x + 5*scale, y - 30*scale, 4*scale, 18*scale);
                ctx.strokeStyle = '#2F4F4F';
                ctx.lineWidth = 1*scale;
                ctx.strokeRect(x + 5*scale, y - 30*scale, 4*scale, 18*scale);
                
                // Smoke particles
                ctx.fillStyle = 'rgba(105, 105, 105, 0.6)';
                for (let i = 0; i < 3; i++) {
                    const smokeX = x + 7*scale + (Math.random() - 0.5) * 4*scale;
                    const smokeY = y - 35*scale - i*5*scale;
                    ctx.beginPath();
                    ctx.arc(smokeX, smokeY, 2*scale, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Masts with rigging
                ctx.strokeStyle = '#2F4F4F';
                ctx.lineWidth = 2*scale;
                ctx.beginPath();
                ctx.moveTo(x - 10*scale, y - 15*scale);
                ctx.lineTo(x - 10*scale, y - 35*scale);
                ctx.moveTo(x + 10*scale, y - 15*scale);
                ctx.lineTo(x + 10*scale, y - 30*scale);
                ctx.stroke();
                
                // Rigging lines
                ctx.strokeStyle = 'rgba(47, 79, 79, 0.7)';
                ctx.lineWidth = 1*scale;
                ctx.beginPath();
                ctx.moveTo(x - 10*scale, y - 30*scale);
                ctx.lineTo(x + 10*scale, y - 25*scale);
                ctx.moveTo(x - 10*scale, y - 25*scale);
                ctx.lineTo(x + 10*scale, y - 30*scale);
                ctx.stroke();
                
                // Enhanced navigation lights with glow
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 6*scale;
                ctx.fillStyle = '#FF0000';
                ctx.beginPath();
                ctx.arc(x - 20*scale, y, 2*scale, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.shadowColor = '#00FF00';
                ctx.fillStyle = '#00FF00';
                ctx.beginPath();
                ctx.arc(x + 20*scale, y, 2*scale, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Bow wave
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2*scale;
                ctx.beginPath();
                ctx.moveTo(x - 22*scale, y + 10*scale);
                ctx.quadraticCurveTo(x - 15*scale, y + 15*scale, x - 25*scale, y + 20*scale);
                ctx.moveTo(x + 22*scale, y + 10*scale);
                ctx.quadraticCurveTo(x + 15*scale, y + 15*scale, x + 25*scale, y + 20*scale);
                ctx.stroke();
                
            } else if (hazard.type === 'reef') {
                // Enhanced reef with more detail
                const x = hazard.pos.x;
                const y = hazard.pos.y;
                const scale = hazard.radius / 35;
                
                // Main reef body with complex organic shape
                const reefGradient = ctx.createRadialGradient(x, y, 0, x, y, hazard.radius);
                reefGradient.addColorStop(0, '#CD853F');
                reefGradient.addColorStop(0.6, '#8B4513');
                reefGradient.addColorStop(1, '#654321');
                
                ctx.fillStyle = reefGradient;
                ctx.beginPath();
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * 2 * Math.PI;
                    const radius = hazard.radius * (0.5 + 0.5 * Math.sin(i * 2.7 + time * 0.01));
                    const px = x + Math.cos(angle) * radius;
                    const py = y + Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                
                // Rock texture overlay
                ctx.fillStyle = 'rgba(139, 69, 19, 0.7)';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * 2 * Math.PI;
                    const distance = hazard.radius * (0.3 + Math.random() * 0.4);
                    const rockX = x + Math.cos(angle) * distance;
                    const rockY = y + Math.sin(angle) * distance;
                    ctx.beginPath();
                    ctx.arc(rockX, rockY, 6*scale + Math.random()*4*scale, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Coral formations with vibrant colors
                const coralColors = ['#FF7F50', '#FF6347', '#FFA500', '#FFD700'];
                coralColors.forEach((color, idx) => {
                    ctx.fillStyle = color;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4 + idx * 0.25) * 2 * Math.PI;
                        const distance = hazard.radius * 0.6;
                        const coralX = x + Math.cos(angle) * distance;
                        const coralY = y + Math.sin(angle) * distance;
                        ctx.beginPath();
                        ctx.arc(coralX, coralY, 5*scale, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
                
                // Animated sea anemones
                ctx.strokeStyle = '#32CD32';
                ctx.lineWidth = 2*scale;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * 2 * Math.PI;
                    const waveOffset = Math.sin(time * 0.05 + i) * 5*scale;
                    const startX = x + Math.cos(angle) * hazard.radius * 0.7;
                    const startY = y + Math.sin(angle) * hazard.radius * 0.7;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.quadraticCurveTo(
                        startX + Math.cos(angle + 0.5) * (15*scale + waveOffset),
                        startY + Math.sin(angle + 0.5) * (15*scale + waveOffset),
                        startX + Math.cos(angle) * (25*scale + waveOffset),
                        startY + Math.sin(angle) * (25*scale + waveOffset)
                    );
                    ctx.stroke();
                }
                
                // Bubble effects with animation
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 6; i++) {
                    const bubbleTime = (time + i * 20) * 0.1;
                    const bubbleX = x + (Math.random() - 0.5) * hazard.radius + Math.sin(bubbleTime) * 10*scale;
                    const bubbleY = y + (Math.random() - 0.5) * hazard.radius - (bubbleTime % 50) * 2*scale;
                    const bubbleSize = 2*scale + Math.sin(bubbleTime * 2) * scale;
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, bubbleSize, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }
        
        function updateNavigationDisplay() {
            // Update course vector display
            document.getElementById('courseVector').textContent = 
                `[${navAnalysis.course.x.toFixed(2)}, ${navAnalysis.course.y.toFixed(2)}]`;
            document.getElementById('courseBearing').textContent = 
                getBearing(vesselPos, stationPos).toFixed(1) + '°';
            
            // Update final navigation vector display
            document.getElementById('navVector').textContent = 
                `[${navAnalysis.final.x.toFixed(2)}, ${navAnalysis.final.y.toFixed(2)}]`;
            document.getElementById('navSpeed').textContent = 
                (Math.sqrt(navAnalysis.final.x ** 2 + navAnalysis.final.y ** 2) * 2).toFixed(2);
            
            // Update hazard analysis
            const analysisDiv = document.getElementById('hazardAnalysis');
            analysisDiv.innerHTML = '';
            
            hazards.forEach((hazard, i) => {
                const dist = distance(vesselPos, hazard.pos);
                const safetyRadius = hazard.radius + safetyBuffer * 25;
                const avoidance = navAnalysis.avoidance.find(a => a.hazardId === hazard.id);
                const drift = navAnalysis.drift.find(d => d.hazardId === hazard.id);
                
                const hazardDiv = document.createElement('div');
                hazardDiv.className = 'obstacle-info';
                const hazardType = hazard.type === 'vessel' ? 'Vessel' : 'Reef';
                hazardDiv.innerHTML = `
                    <strong>${hazardType} ${i + 1}:</strong><br>
                    Distance: ${(dist / 10).toFixed(1)} meters<br>
                    Safety Zone: ${(safetyRadius / 10).toFixed(1)} meters<br>
                    ${avoidance ? `Avoidance: [${avoidance.x.toFixed(2)}, ${avoidance.y.toFixed(2)}]` : 'No avoidance needed'}<br>
                    ${drift ? `Current Drift: [${drift.x.toFixed(2)}, ${drift.y.toFixed(2)}]` : 'No drift adjustment'}
                `;
                analysisDiv.appendChild(hazardDiv);
            });
            
            // Update status
            document.getElementById('currentStationDistance').textContent = (distance(vesselPos, stationPos) / 100).toFixed(2);
            const closestDist = Math.min(...hazards.map(hazard => distance(vesselPos, hazard.pos)));
            document.getElementById('closestHazard').textContent = (closestDist / 10).toFixed(1);
            document.getElementById('missionTime').textContent = (time / 180).toFixed(2);
        }
        
        function drawWaterPattern() {
            // Draw water waves pattern
            ctx.strokeStyle = 'rgba(135, 206, 235, 0.3)';
            ctx.lineWidth = 1;
            for (let y = 0; y < canvas.height; y += 30) {
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 10) {
                    const wave = Math.sin((x + time * 0.5) * 0.02) * 3;
                    if (x === 0) ctx.moveTo(x, y + wave);
                    else ctx.lineTo(x, y + wave);
                }
                ctx.stroke();
            }
        }
        
        function animate() {
            if (!isPaused) {
                // Update hazard positions (other vessels moving, reefs static)
                hazards.forEach(hazard => {
                    if (hazard.type === 'vessel') {
                        hazard.pos.x += hazard.vel.x;
                        hazard.pos.y += hazard.vel.y;
                        
                        // Bounce off boundaries (vessels turn around)
                        if (hazard.pos.x < hazard.radius || hazard.pos.x > canvas.width - hazard.radius) {
                            hazard.vel.x *= -1;
                        }
                        if (hazard.pos.y < hazard.radius || hazard.pos.y > canvas.height - hazard.radius) {
                            hazard.vel.y *= -1;
                        }
                    } else {
                        // Reefs drift slightly with current
                        hazard.pos.x += hazard.vel.x * 0.3;
                        hazard.pos.y += hazard.vel.y * 0.3;
                        
                        if (hazard.pos.x < hazard.radius || hazard.pos.x > canvas.width - hazard.radius) {
                            hazard.vel.x *= -1;
                        }
                        if (hazard.pos.y < hazard.radius || hazard.pos.y > canvas.height - hazard.radius) {
                            hazard.vel.y *= -1;
                        }
                    }
                });
                
                // Sonar detection with noise
                const detectedHazards = sonarDetection(hazards);
                
                // Navigation control
                const navigation = marineNavigationCBF(vesselPos, stationPos, detectedHazards);
                
                // Update vessel position
                vesselPos.x += navigation.x;
                vesselPos.y += navigation.y;
                
                // Keep vessel in navigation area
                vesselPos.x = Math.max(20, Math.min(canvas.width - 20, vesselPos.x));
                vesselPos.y = Math.max(20, Math.min(canvas.height - 20, vesselPos.y));
                
                // Update vessel track
                track.push({ ...vesselPos });
                if (track.length > maxTrackLength) {
                    track.shift();
                }
                
                time++;
            }
            
            // Clear canvas with ocean gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#001122');
            gradient.addColorStop(0.5, '#003366');
            gradient.addColorStop(1, '#004080');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw water pattern
            drawWaterPattern();
            
            // Draw navigation grid (like maritime charts)
            ctx.strokeStyle = 'rgba(70, 130, 180, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 8]);
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Draw vessel track (wake)
            ctx.strokeStyle = '#4682B4';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            for (let i = 1; i < track.length; i++) {
                const alpha = i / track.length;
                ctx.globalAlpha = alpha * 0.7;
                ctx.moveTo(track[i-1].x, track[i-1].y);
                ctx.lineTo(track[i].x, track[i].y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            
            // Draw hazards with safety zones
            hazards.forEach((hazard, i) => {
                // Safety zone
                ctx.strokeStyle = hazard.type === 'vessel' ? '#FF6B6B' : '#D2691E';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                ctx.arc(hazard.pos.x, hazard.pos.y, hazard.radius + safetyBuffer * 25, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw the hazard
                drawHazard(hazard);
                
                // Label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 11px Arial';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(`${hazard.type === 'vessel' ? 'V' : 'R'}${i+1}`, hazard.pos.x - 8, hazard.pos.y + 4);
                ctx.fillText(`${hazard.type === 'vessel' ? 'V' : 'R'}${i+1}`, hazard.pos.x - 8, hazard.pos.y + 4);
            });
            
            // Draw sonar detection indicators (with noise)
            if (!isPaused) {
                const detectedHazards = sonarDetection(hazards);
                detectedHazards.forEach(hazard => {
                    ctx.strokeStyle = '#FF4500';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    // Draw sonar ping cross
                    ctx.beginPath();
                    ctx.moveTo(hazard.pos.x - 12, hazard.pos.y - 12);
                    ctx.lineTo(hazard.pos.x + 12, hazard.pos.y + 12);
                    ctx.moveTo(hazard.pos.x + 12, hazard.pos.y - 12);
                    ctx.lineTo(hazard.pos.x - 12, hazard.pos.y + 12);
                    ctx.stroke();
                    
                    // Draw sonar detection circle
                    ctx.beginPath();
                    ctx.arc(hazard.pos.x, hazard.pos.y, 15, 0, 2 * Math.PI);
                    ctx.stroke();
                });
            }
            
            // Draw research vessel
            drawVessel(vesselPos);
            
            // Draw research station
            drawResearchStation(stationPos);
            
            // Draw navigation vectors
            if (navAnalysis.course) {
                drawArrow(vesselPos, navAnalysis.course, 80, '#DAA520', 4);
            }
            
            navAnalysis.avoidance?.forEach(avoid => {
                drawArrow(vesselPos, avoid, 60, '#DC143C', 3);
            });
            
            navAnalysis.drift?.forEach(drift => {
                drawArrow(vesselPos, drift, 50, '#8A2BE2', 2);
            });
            
            if (navAnalysis.final) {
                const finalNorm = normalize(navAnalysis.final);
                drawArrow(vesselPos, finalNorm, 90, '#228B22', 5);
            }
            
            updateNavigationDisplay();
            requestAnimationFrame(animate);
        }
        
        // Initialize simulation
        animate();
    </script>
</body>
</html>